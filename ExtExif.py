"""
Title: Bulk compare the reported file extension with the actual file extension.
Author: Primus27
"""

import os
import sys
from pathlib import Path
import argparse
import logging
from datetime import datetime
try:
    from termcolor import colored as colour
except ImportError:
    print("'termcolor' module is missing.")
    exit()

current_version = 1.0


def format_stdout(stdout):
    """
    Formats stdout for use in the log file
    :param stdout: Results generated by command
    :return: List containing the attribute and the value
    """
    # Convert each item to an attribute, value pair (string)
    attr_list = str(stdout).split("\n")

    # Each sub item is an attribute or value
    attr_list = [str(pair).split(":") for pair in attr_list]

    # Remove whitespace
    for index, pair in enumerate(attr_list):
        for i, value in enumerate(pair):
            attr_list[index][i] = value.strip()
    del attr_list[-1]

    return attr_list


def scan_file(file):
    """
    Scans file using exiftool for extensions
    :param file: File to be scanned
    :return: Tuple containing a flag, extension and the actual extension
    """
    # Set defaults
    ext_reported = "N/A"
    ext_actual = "N/A"
    file_error = None
    ext_actual_flag = False
    ext_reported_flag = False

    # Run exiftool
    results = os.popen(f"exiftool {file} | "
                       f"grep 'File Name\|File Type\|Error'").read()

    # No error found
    if not str(results).startswith("File not found"):
        # Format new results and convert to list w/ attribute, value pairs
        results_list = format_stdout(results)

        # Logging
        if log_all_flag:
            logging.info(f"exiftool successful on {file}")
            logging.info(f"exiftool stdout: {results_list}")

        # Iterate through list and assign values when correct attribute found
        for line in results_list:
            if "File Name" in line[0]:
                ext_reported = line[1].split(".")[-1].lower()
                ext_reported_flag = True
            elif "File Type Extension" in line[0]:
                ext_actual = line[1]
                ext_actual_flag = True
            elif "Error" in line[0]:
                file_error = line[1]
    else:  # Error found
        if log_flag or log_all_flag:
            logging.critical(f"exiftool unsuccessful on {file}")
            logging.info(f"exiftool stdout: {results}")

    # Both extensions were found
    ext_found_flag = True if all(flag is True for flag in
                                 [ext_actual_flag, ext_reported_flag]
                                 ) else False

    # No reported or actual flag found
    if not ext_found_flag and (log_flag or log_all_flag):
        logging.warning(f"Reported filetype: {ext_reported} "
                        f"| Actual filetype: {ext_actual}")
    # Both reported and actual flags found
    elif log_flag or log_all_flag:
        logging.info(f"Reported filetype: {ext_reported} "
                     f"| Actual filetype: {ext_actual}")
    # Comparing flags
    if ext_found_flag:
        if log_all_flag:
            logging.info(f"All metadata in {file} found\n")
    elif log_flag or log_all_flag:
        nline = "\n" if not file_error else ""
        logging.critical(f"1 or more filetype metadata values missing{nline}")

    return ext_found_flag, ext_reported, ext_actual, file_error


def enum_files(folder_path):
    """
    Enumerates files in a path.
    :param folder_path: Root folder path for enumeration.
    :return: List containing all files in a folder.
    """
    # List of all files in path
    f_list = []
    # Enumerate files
    for root, dirs, files in os.walk(folder_path, topdown=True):
        for file in files:
            # Generate the absolute/relative path for each file
            file_path = str(os.path.join(root, file)).replace(" ","\\ ")
            f_list.append(file_path)

    # Available files to scan
    if log_all_flag and len(f_list) > 0:
        logging.info(f"Available files: {f_list}\n")
    # No files found
    elif len(f_list) == 0:
        print(colour("[*] No files found in specified directory\n", "red"))
        if log_flag or log_all_flag:
            logging.critical("No files found in specified directory\n")

    return f_list


def check_match(extension1, extension2):
    """
    Check whether the file extensions match
    :param extension1: Reported extension seen in explorer
    :param extension2: Actual extension based on byte sequence
    :return: Boolean value on match
    """
    # Extensions match
    if extension1 == extension2:
        return True
    # Extensions don't match but may be the same e.g. jpg, jpeg
    for file_type_group in syn_filetypes:
        if extension1 in file_type_group and extension2 in file_type_group:
            return True
    # Extensions don't match
    return False


def check_exiftool_exists():
    """
    Check whether exiftool package exists on OS
    :return: Boolean value on whether it exists
    """
    if str(os.popen("exiftool").read()).startswith(
            "bash: exiftool: command not found"):
        if log_all_flag:
            logging.critical("exiftool not installed")
        return False
    else:
        if log_flag or log_all_flag:
            logging.info("exiftool install verified")
        return True


def main():
    """
    Main method
    """
    # Close program if exiftool is not installed
    if not check_exiftool_exists():
        print(colour("[*] Exiftool package not installed", "red"))
        sys.exit(5)

    # Output current time of scan
    print(colour(f"[*] Scan started: {datetime.now()}\n", "green"))

    # Enumerate files in path
    file_list = enum_files(scan_path)

    # Count number of files scanned
    total_files = len(file_list)
    scanned_files = 0

    # Scan each file and output result
    for filename in file_list:
        extension_results = scan_file(filename)

        # All file extension(s) found
        if extension_results[0]:
            print(filename)
            extensions_match = check_match(extension_results[1],
                                           extension_results[2])
            print(f"Match: {extensions_match}")
        # All file extension(s) not found
        else:
            nline = "\n" if not extension_results[3] else ""
            print(f"{filename}")
            print(f"Critical: 1 or more extensions not found{nline}")

        # Error reported by exiftool
        if extension_results[3]:
            print(f"Error: {extension_results[3]}")
            if log_flag or log_all_flag:
                logging.error(f"{extension_results[3]}\n")

        print(f"Reported: {extension_results[1]} "
              f"| Actual: {extension_results[2]}\n")

        scanned_files += 1

    # Output comparison of scanned files to total files
    col_code = "green" if scanned_files == total_files else "red"
    print(colour(f"[*] {scanned_files}/{total_files} Files scanned", col_code))


if __name__ == '__main__':
    # Define argument parser
    parser = argparse.ArgumentParser()

    # Remove existing action groups
    parser._action_groups.pop()

    # Create a required and optional group
    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")

    # Define arguments
    required.add_argument("-sP", "--scanPath", action="store", dest="path",
                          help="Scan path (absolute or relative)",
                          required=True)
    optional.add_argument("-l", "--log", action="store_true",
                          dest="log_flag", help="Enable error logging")
    optional.add_argument("-la", "--logAll", action="store_true",
                          dest="log_all_flag", help="Enable complete logging")
    optional.add_argument("-o", "--toOutput", action="store_true",
                          dest="output_friendly", help="Removes ANSI escape \
                            sequences for colour in terminal. This makes it \
                            ideal for outputting")
    optional.add_argument("--version", action="version",
                          version=f"%(prog)s {current_version}",
                          help="Display program version")
    args = parser.parse_args()

    # Args
    scan_path = Path(args.path)
    log_flag = args.log_flag
    log_all_flag = args.log_all_flag
    output_friendly = args.output_friendly

    if output_friendly:
        def colour(message, tc_colour):
            """
            Overwrites the termcolor "color" function so that the output
            features no escape sequences (for colour). This means it can be
            output to a file without the escape sequences
            :param message: Message for print statement
            :param tc_colour: Colour otherwise for termcolor
            :return: Message that was input
            """
            return message

    # Set default logging params
    log_filename = "ExtExif.log"
    if log_flag or log_all_flag:
        logging.basicConfig(filename=log_filename, level=logging.INFO,
                            format="%(asctime)s : %(levelname)s : %(message)s")
    else:
        logging.basicConfig(level=logging.INFO,
                            format="%(asctime)s : %(levelname)s : %(message)s")

    if log_flag or log_all_flag:
        if os.path.exists(log_filename) and os.path.getsize(log_filename) > 0:
            with open(log_filename, "a") as lf:
                lf.write("\n")

    # Extensions that should be treated the same
    syn_filetypes = (
        ("jpg", "jpeg", "jpe"),
        ("html", "htm")
    )

    # Main method
    main()
